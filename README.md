# PR Reviewer Assignment Service

Микросервис для автоматического назначения ревьюверов на Pull Request'ы. Сервис управляет командами, пользователями и автоматически назначает до 2 активных ревьюверов из команды автора при создании PR.

## Содержание

- [Описание](#описание)
- [Архитектура](#архитектура)
- [Требования](#требования)
- [Быстрый старт](#быстрый-старт)
- [API Документация](#api-документация)
- [Разработка](#разработка)
- [Тестирование](#тестирование)
- [Производительность](#производительность)

## Описание

Сервис предоставляет REST API для управления командами разработчиков и автоматического назначения ревьюверов на Pull Request'ы. Основные возможности:

- **Управление командами**: создание, получение и удаление команд с участниками
- **Управление пользователями**: установка флага активности, получение списка PR для ревью
- **Управление Pull Request'ами**: создание PR с автоматическим назначением ревьюверов, слияние PR, переназначение ревьюверов
- **Статистика**: комплексная статистика по командам, пользователям и PR

### Бизнес-логика

1. При создании PR автоматически назначаются **до двух** активных ревьюверов из **команды автора**, исключая самого автора
2. Переназначение заменяет одного ревьювера на случайного **активного** участника **из команды заменяемого** ревьювера
3. После `MERGED` менять список ревьюверов **нельзя**
4. Если доступных кандидатов меньше двух, назначается доступное количество (0/1)
5. Пользователь с `isActive = false` не назначается на ревью
6. Операция merge **идемпотентна** — повторный вызов не приводит к ошибке

## Архитектура

Проект следует принципам Clean Architecture и разделён на следующие слои:

```
services/pr-manager/
├── api/              # HTTP handlers и DTO
│   └── handlers/     # Обработчики HTTP запросов
├── cmd/              # Точка входа приложения
└── internal/
    ├── application/  # Слой приложения (use cases)
    └── domain/       # Доменная логика и модели
        ├── db/       # Реализация хранилища (PostgreSQL)
        ├── manager/  # Бизнес-логика
        └── storager/ # Интерфейсы хранилища
```

### Технологический стек

- **Язык**: Go 1.25.1
- **База данных**: PostgreSQL 17.2
- **HTTP сервер**: стандартная библиотека `net/http`
- **Драйвер БД**: `pgx/v5`

## Требования

- Docker и Docker Compose
- Go 1.25.1+ (для локальной разработки)

## Быстрый старт

### Запуск через Docker Compose

1. Клонируйте репозиторий:

```bash
git clone <repository-url>
cd pr-manager
```

2. Создайте (или воспользуйтесь уже созданным мною; я оставил его для упрощения запуска приложения) файл с переменными окружения для базы данных:

```bash
cat > secrets/db.env << EOF
POSTGRES_USER=prmanager
POSTGRES_PASSWORD=prmanager
POSTGRES_DB=prmanager
DB_HOST=db
DB_PORT=5432
DB_USER=prmanager
DB_PASSWORD=prmanager
DB_NAME=prmanager
EOF
```

3. Запустите сервис:

```bash
docker-compose up --build
```

Сервис будет доступен на `http://localhost:8080`

## API Документация

Полная спецификация API доступна в файле [openapi.yml](./openapi.yml) в формате OpenAPI 3.1.3.

### Основные эндпоинты

#### Команды

- `POST /team/add` - Создать команду с участниками
- `GET /team/get?name={team_name}` - Получить команду
- `DELETE /team/delete?name={team_name}` - Удалить команду

#### Пользователи

- `POST /users/setIsActive` - Установить флаг активности пользователя
- `GET /users/getReview?user_id={user_id}` - Получить PR'ы пользователя для ревью

#### Pull Request'ы

- `POST /pullRequest/create` - Создать PR и назначить ревьюверов
- `POST /pullRequest/merge` - Пометить PR как MERGED
- `POST /pullRequest/reassign` - Переназначить ревьювера

#### Статистика

- `GET /stats/get` - Получить статистику по командам, пользователям и PR

### Примеры запросов

#### Создание команды

```bash
curl -X POST http://localhost:8080/team/add \
  -H "Content-Type: application/json" \
  -d '{
    "team_name": "backend",
    "members": [
      {"user_id": "u1", "username": "Alice", "is_active": true},
      {"user_id": "u2", "username": "Bob", "is_active": true}
    ]
  }'
```

#### Создание PR

```bash
curl -X POST http://localhost:8080/pullRequest/create \
  -H "Content-Type: application/json" \
  -d '{
    "pull_request_id": "pr-1001",
    "pull_request_name": "Add search feature",
    "author_id": "u1"
  }'
```

#### Получение статистики

```bash
curl http://localhost:8080/stats/get
```

## Разработка

### Структура проекта

Проект организован по принципам Clean Architecture:

- **Domain Layer** (`internal/domain/`): содержит бизнес-логику, модели данных и интерфейсы
- **Application Layer** (`internal/application/`): содержит use cases и оркестрацию бизнес-логики
- **API Layer** (`api/handlers/`): содержит HTTP handlers и преобразование данных

### Форматирование кода

Используются стандартные инструменты Go:

```bash
go fmt ./...
go vet ./...
```

## Тестирование

### Интеграционные тесты

Интеграционные тесты находятся в `api/handlers/` и `internal/application/`. Они проверяют взаимодействие между слоями приложения.

## Производительность

### Требования

- **RPS**: 5 запросов в секунду
- **SLI времени ответа**: 300 мс
- **SLI успешности**: 99.9%
- **Объём данных**: до 20 команд, до 200 пользователей

### Оптимизации

- Использование пула соединений с БД
- Транзакции для обеспечения консистентности данных
- Параллельная загрузка данных при расчёте статистики

## Решения и допущения

### Вопросы, решённые в процессе разработки

1. **Формат хранения ревьюверов**: Ревьюверы хранятся в БД как строка с разделителями (формат `[user1,user2]`) (взял из описания доменной модели в тексте задания; более удобно было бы ревьюверов хранить как список и сделать отдельную таблицу для нормализации).

2. **Удаление команды**: При удалении команды также удаляются все связанные пользователи (на самом деле они помечаются удаленными, а не удаляются физически). Это упрощает управление данными, но может быть изменено в будущем для поддержки пользователей без команды.

3. **Статистика**: Статистика рассчитывается синхронно при каждом запросе. Для больших объёмов данных можно добавить кэширование или фоновые задачи.

4. **Обработка ошибок**: Все ошибки возвращаются в едином формате `ErrorResponse` с кодами ошибок для удобной обработки на клиенте.
